# 预测回滚中的碰撞状态存储方案

## 问题背景

在帧同步的预测回滚系统中，仅存储物理体的位置和速度是不够的。物理系统还需要维护碰撞状态（Enter、Stay、Exit）来正确触发碰撞事件。

### 问题分析

1. **碰撞事件的计算依赖历史状态**
   - `Enter`: 当前帧碰撞但上一帧未碰撞的物体
   - `Stay`: 当前帧和上一帧都碰撞的物体
   - `Exit`: 上一帧碰撞但当前帧未碰撞的物体

2. **回滚时的状态丢失**
   - 如果只恢复位置和速度，`LastRigidBody2D`（上一帧的碰撞列表）会丢失
   - 导致回滚后重新运行物理模拟时，Enter/Stay/Exit计算错误

## 商业游戏的做法

### 1. **完整状态存储（推荐）**

商业游戏（如《英雄联盟》、《王者荣耀》等MOBA游戏）通常采用以下策略：

#### 核心原则
- **存储足够的物理状态**，使得可以完全重现物理模拟
- **不直接存储事件**，而是存储产生事件所需的状态
- **通过重新运行物理模拟**来重新计算碰撞状态

#### 需要存储的状态
```csharp
// 基础物理状态
- 位置 (Position)
- 速度 (Velocity)
- 旋转 (Rotation) - 如果有旋转
- 角速度 (AngularVelocity) - 如果有旋转

// 碰撞历史状态（关键！）
- LastCollidingBodyIds: 上一帧碰撞的物理体ID列表

// 其他可能需要的状态
- 质量 (Mass)
- 弹性系数 (Restitution)
- 摩擦系数 (Friction)
- 线性阻尼 (LinearDamping)
```

### 2. **事件系统设计**

商业游戏通常采用**事件队列**而非直接存储事件：

```
回滚流程：
1. 恢复到目标帧的状态（包括LastCollidingBodyIds）
2. 重新运行物理模拟（从目标帧到当前帧）
3. 在重新运行过程中，重新触发所有事件（Enter/Stay/Exit）
4. 事件监听器会收到这些事件，但需要处理重复触发的问题
```

### 3. **引用问题的解决**

商业游戏的做法：

#### 方案A：ID映射系统（我们采用的方案）
- **存储ID而非引用**：GameState中只存储物理体ID
- **运行时映射**：通过ID映射表（`bodyIdToRigidBody`）查找实际对象
- **优点**：状态可序列化、确定性、不依赖Unity对象生命周期
- **缺点**：需要维护ID映射表

#### 方案B：弱引用系统
- 使用弱引用存储对象
- 优点：不需要ID映射
- 缺点：Unity不支持弱引用，且可能导致内存泄漏

#### 方案C：实体组件系统（ECS）⭐ 推荐
- 使用Entity ID而非对象引用
- 优点：完全解耦，适合大规模游戏，状态快照非常简单
- 缺点：需要重构现有代码
- **实现方式**：参见 `ECS预测回滚实现方案.md`

**核心思想**：
- Entity：只是一个ID（int），不包含任何数据
- Component：纯数据结构，只包含数据，不包含逻辑
- World：管理所有Entity和Component
- 状态快照 = 所有Component的快照
- 回滚 = 恢复所有Component的状态

**示例代码**：
```csharp
// 1. 创建World
var world = new World();

// 2. 注册物理体到ECS
var entity = ECSPhysicsSyncHelper.RegisterRigidBody(world, rigidBody);

// 3. 保存状态快照
var snapshot = ECSGameState.CreateSnapshot(world, frameNumber);

// 4. 回滚
snapshot.RestoreToWorld(world);
ECSPhysicsSyncHelper.SaveFromWorldToUnity(world);
```

**碰撞状态处理**：
```csharp
// CollisionComponent只存储Entity ID
public struct CollisionComponent : IComponent
{
    public List<int> lastCollidingEntityIds;  // 只存储Entity ID，不存储引用
}
```

**优势**：
1. 完全解耦：Entity ID是稳定的，不依赖Unity对象生命周期
2. 易于序列化：Component是纯数据，可以直接序列化
3. 状态快照简单：状态快照就是Component的快照
4. 回滚简单：回滚时直接恢复Component即可
5. 易于扩展：添加新Component类型不需要修改GameState

## 我们的实现方案

### 1. 扩展PhysicsBodyState

```csharp
public class PhysicsBodyState
{
    public int bodyId;                    // 物理体ID
    public FixVector2 position;            // 位置
    public FixVector2 velocity;            // 速度
    public List<int> lastCollidingBodyIds; // 上一帧碰撞的物理体ID列表（关键！）
}
```

### 2. 保存状态时

```csharp
// 在PhysicsSyncHelper.SaveToGameState中
// 提取LastRigidBody2D中的ID列表（只存储ID，不存储引用）
List<int> lastCollidingBodyIds = new List<int>();
foreach (var collidingBody in body.LastRigidBody2D)
{
    if (collidingBody != null && collidingBody.id > 0)
    {
        lastCollidingBodyIds.Add(collidingBody.id);
    }
}
```

### 3. 恢复状态时

```csharp
// 在PhysicsSyncHelper.RestoreFromGameState中
// 恢复碰撞状态：重建LastRigidBody2D列表（通过ID查找对应的RigidBody2D对象）
body.LastRigidBody2D.Clear();
foreach (var collidingBodyId in bodyState.lastCollidingBodyIds)
{
    if (bodyIdToRigidBody.TryGetValue(collidingBodyId, out RigidBody2D collidingBody))
    {
        body.LastRigidBody2D.Add(collidingBody);
    }
}

// 清空当前帧的碰撞列表，让物理系统重新计算
body.CurrentRigidBody2D.Clear();
body.Enter.Clear();
body.Stay.Clear();
body.Exit.Clear();
```

## 工作流程

### 正常帧执行流程

```
帧N:
1. 恢复状态（包括LastRigidBody2D）
2. 执行物理模拟
3. 物理系统计算碰撞，填充CurrentRigidBody2D
4. ProcessAllBody()计算Enter/Stay/Exit：
   - Enter = CurrentRigidBody2D - LastRigidBody2D
   - Stay = CurrentRigidBody2D ∩ LastRigidBody2D
   - Exit = LastRigidBody2D - CurrentRigidBody2D
5. 更新LastRigidBody2D = CurrentRigidBody2D
6. 保存状态（包括LastRigidBody2D的ID列表）
```

### 回滚流程

```
回滚到帧N:
1. 加载帧N的快照（包括LastCollidingBodyIds）
2. 恢复所有物理体状态：
   - Position, Velocity
   - LastRigidBody2D（通过ID重建）
3. 清空CurrentRigidBody2D、Enter、Stay、Exit
4. 重新执行物理模拟（从帧N到当前帧）
5. 物理系统会重新计算所有碰撞状态和事件
```

## 注意事项

### 1. 物理体销毁处理

如果回滚时某个物理体已被销毁（不在`bodyIdToRigidBody`中），应该：
- 跳过该物理体的恢复
- 在恢复碰撞列表时，如果找不到对应的物理体，跳过该ID

### 2. 确定性保证

- 使用ID而非引用，确保状态可序列化
- 使用OrderedDictionary确保遍历顺序一致
- 碰撞列表的ID应该排序，确保确定性

### 3. 性能优化

- 只在需要回滚的物理体上存储碰撞状态
- 静态物体不需要存储碰撞状态（它们不会移动）
- 使用对象池减少GC压力

## 总结

商业游戏在预测回滚系统中处理碰撞状态的核心思路是：

1. **存储完整的物理状态**，包括碰撞历史
2. **使用ID而非引用**，保证状态可序列化和确定性
3. **通过重新运行物理模拟**来重新计算碰撞事件
4. **事件系统设计**：事件在重新运行过程中重新触发，而非直接存储事件

我们的实现遵循了这些原则，通过存储`LastCollidingBodyIds`来确保回滚后能正确计算Enter/Stay/Exit事件。

