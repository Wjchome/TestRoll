# 确定性寻路实现方案

## 一、确定性寻路的核心挑战

### 1.1 为什么需要确定性？

在帧同步游戏中，**所有客户端必须产生完全相同的路径**，否则会导致：
- 客户端状态不一致
- 回滚时路径不同
- 游戏逻辑错误

### 1.2 确定性寻路的关键要求

1. **固定点数学**：不能使用浮点数（精度问题）
2. **确定性排序**：当F值相同时，必须有确定的tie-breaker
3. **无随机性**：不能使用任何随机数
4. **确定性数据结构**：优先队列、集合等必须有序且确定

## 二、算法选择

### 2.1 A* 算法（推荐）

**优势**：
- ✅ 高效：比Dijkstra快
- ✅ 最优：能找到最短路径
- ✅ 可确定性：容易实现确定性版本

**关键点**：
- 使用固定点数学（Fix64）
- 确定性的tie-breaker
- 确定性的优先队列

### 2.2 网格地图（Grid Map）

**优势**：
- ✅ 简单：易于实现
- ✅ 确定性：网格坐标是整数，天然确定
- ✅ 性能好：查找邻居O(1)

## 三、实现方案

### 3.1 数据结构设计

```csharp
// 网格节点
public struct GridNode : IEquatable<GridNode>
{
    public int x;
    public int y;
    
    public GridNode(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    
    // 确定性比较
    public bool Equals(GridNode other)
    {
        return x == other.x && y == other.y;
    }
    
    public override int GetHashCode()
    {
        return x * 10000 + y; // 假设y < 10000
    }
}

// A* 节点（包含路径信息）
public struct AStarNode : IComparable<AStarNode>
{
    public GridNode position;
    public Fix64 g;  // 从起点到当前节点的实际代价
    public Fix64 h;  // 从当前节点到终点的启发式代价
    public Fix64 f;  // f = g + h
    public GridNode parent;  // 父节点（用于重建路径）
    
    // 确定性比较：当f相同时，使用位置作为tie-breaker
    public int CompareTo(AStarNode other)
    {
        // 首先比较f值
        int fCompare = f.CompareTo(other.f);
        if (fCompare != 0)
            return fCompare;
        
        // f值相同时，使用位置作为tie-breaker（确保确定性）
        int xCompare = position.x.CompareTo(other.position.x);
        if (xCompare != 0)
            return xCompare;
        
        return position.y.CompareTo(other.position.y);
    }
}
```

### 3.2 地图组件

```csharp
// 地图组件：存储网格地图信息
public struct GridMapComponent : IComponent
{
    // 地图宽度和高度（网格数）
    public int width;
    public int height;
    
    // 网格大小（世界单位）
    public Fix64 cellSize;
    
    // 障碍物集合（使用HashSet，但遍历时排序确保确定性）
    public OrderedHashSet<GridNode> obstacles;
    
    public GridMapComponent(int width, int height, Fix64 cellSize)
    {
        this.width = width;
        this.height = height;
        this.cellSize = cellSize;
        this.obstacles = new OrderedHashSet<GridNode>();
    }
    
    // 检查节点是否可通行
    public bool IsWalkable(GridNode node)
    {
        // 检查边界
        if (node.x < 0 || node.x >= width || node.y < 0 || node.y >= height)
            return false;
        
        // 检查障碍物
        return !obstacles.Contains(node);
    }
    
    // 世界坐标转网格坐标
    public GridNode WorldToGrid(FixVector2 worldPos)
    {
        int x = (int)(worldPos.x / cellSize);
        int y = (int)(worldPos.y / cellSize);
        return new GridNode(x, y);
    }
    
    // 网格坐标转世界坐标
    public FixVector2 GridToWorld(GridNode gridPos)
    {
        Fix64 worldX = (Fix64)gridPos.x * cellSize + cellSize / 2;
        Fix64 worldY = (Fix64)gridPos.y * cellSize + cellSize / 2;
        return new FixVector2(worldX, worldY);
    }
}
```

### 3.3 确定性A*算法实现

```csharp
using System;
using System.Collections.Generic;
using Frame.FixMath;

namespace Frame.ECS
{
    /// <summary>
    /// 确定性A*寻路算法
    /// 使用固定点数学，确保所有客户端产生相同的路径
    /// </summary>
    public static class DeterministicPathfinding
    {
        /// <summary>
        /// 使用A*算法查找路径
        /// </summary>
        /// <param name="map">地图组件</param>
        /// <param name="start">起点（世界坐标）</param>
        /// <param name="end">终点（世界坐标）</param>
        /// <returns>路径（世界坐标列表），如果找不到路径返回null</returns>
        public static List<FixVector2> FindPath(GridMapComponent map, FixVector2 start, FixVector2 end)
        {
            GridNode startNode = map.WorldToGrid(start);
            GridNode endNode = map.WorldToGrid(end);
            
            // 检查起点和终点是否可通行
            if (!map.IsWalkable(startNode) || !map.IsWalkable(endNode))
            {
                return null;
            }
            
            // 如果起点和终点相同，直接返回
            if (startNode.Equals(endNode))
            {
                return new List<FixVector2> { start, end };
            }
            
            // A*算法
            var openSet = new SortedSet<AStarNode>();  // 使用SortedSet确保确定性排序
            var closedSet = new HashSet<GridNode>();
            var cameFrom = new Dictionary<GridNode, GridNode>();
            var gScore = new Dictionary<GridNode, Fix64>();
            var fScore = new Dictionary<GridNode, Fix64>();
            
            // 初始化起点
            gScore[startNode] = Fix64.Zero;
            fScore[startNode] = Heuristic(startNode, endNode);
            openSet.Add(new AStarNode
            {
                position = startNode,
                g = Fix64.Zero,
                h = fScore[startNode],
                f = fScore[startNode],
                parent = new GridNode(-1, -1)  // 无效父节点
            });
            
            while (openSet.Count > 0)
            {
                // 获取f值最小的节点（SortedSet自动排序）
                var current = openSet.Min;
                openSet.Remove(current);
                
                GridNode currentPos = current.position;
                
                // 如果到达终点，重建路径
                if (currentPos.Equals(endNode))
                {
                    return ReconstructPath(cameFrom, currentPos, map);
                }
                
                closedSet.Add(currentPos);
                
                // 检查所有邻居
                foreach (var neighbor in GetNeighbors(currentPos, map))
                {
                    if (closedSet.Contains(neighbor))
                        continue;
                    
                    // 计算从起点到邻居的代价
                    Fix64 tentativeG = gScore[currentPos] + GetDistance(currentPos, neighbor);
                    
                    if (!gScore.ContainsKey(neighbor) || tentativeG < gScore[neighbor])
                    {
                        cameFrom[neighbor] = currentPos;
                        gScore[neighbor] = tentativeG;
                        fScore[neighbor] = tentativeG + Heuristic(neighbor, endNode);
                        
                        // 添加到开放集
                        openSet.Add(new AStarNode
                        {
                            position = neighbor,
                            g = tentativeG,
                            h = Heuristic(neighbor, endNode),
                            f = fScore[neighbor],
                            parent = currentPos
                        });
                    }
                }
            }
            
            // 找不到路径
            return null;
        }
        
        /// <summary>
        /// 获取节点的邻居（8方向或4方向）
        /// </summary>
        private static List<GridNode> GetNeighbors(GridNode node, GridMapComponent map)
        {
            var neighbors = new List<GridNode>();
            
            // 8方向移动（包括对角线）
            int[] dx = { -1, 0, 1, -1, 1, -1, 0, 1 };
            int[] dy = { -1, -1, -1, 0, 0, 1, 1, 1 };
            
            // 或者4方向移动（上下左右）
            // int[] dx = { -1, 0, 1, 0 };
            // int[] dy = { 0, -1, 0, 1 };
            
            for (int i = 0; i < dx.Length; i++)
            {
                GridNode neighbor = new GridNode(node.x + dx[i], node.y + dy[i]);
                if (map.IsWalkable(neighbor))
                {
                    neighbors.Add(neighbor);
                }
            }
            
            // 确保顺序确定（按x, y排序）
            neighbors.Sort((a, b) =>
            {
                int xCompare = a.x.CompareTo(b.x);
                if (xCompare != 0) return xCompare;
                return a.y.CompareTo(b.y);
            });
            
            return neighbors;
        }
        
        /// <summary>
        /// 启发式函数：曼哈顿距离（确定性）
        /// </summary>
        private static Fix64 Heuristic(GridNode a, GridNode b)
        {
            int dx = Math.Abs(a.x - b.x);
            int dy = Math.Abs(a.y - b.y);
            return new Fix64(dx + dy);
        }
        
        /// <summary>
        /// 计算两个节点之间的距离（确定性）
        /// </summary>
        private static Fix64 GetDistance(GridNode a, GridNode b)
        {
            int dx = Math.Abs(a.x - b.x);
            int dy = Math.Abs(a.y - b.y);
            
            // 如果是对角线移动，距离是√2，否则是1
            if (dx == 1 && dy == 1)
            {
                // 使用固定点数学计算√2
                // √2 ≈ 1.414，转换为Fix64
                return new Fix64(1414) / new Fix64(1000);  // 近似值
            }
            else
            {
                return new Fix64(dx + dy);
            }
        }
        
        /// <summary>
        /// 重建路径（从终点回溯到起点）
        /// </summary>
        private static List<FixVector2> ReconstructPath(
            Dictionary<GridNode, GridNode> cameFrom, 
            GridNode current, 
            GridMapComponent map)
        {
            var path = new List<FixVector2>();
            path.Add(map.GridToWorld(current));
            
            while (cameFrom.ContainsKey(current))
            {
                current = cameFrom[current];
                path.Add(map.GridToWorld(current));
            }
            
            // 反转路径（从起点到终点）
            path.Reverse();
            return path;
        }
    }
}
```

## 四、确定性保证

### 4.1 固定点数学

```csharp
// 所有计算使用 Fix64，不使用 float/double
Fix64 distance = Heuristic(nodeA, nodeB);
Fix64 cost = gScore[current] + GetDistance(current, neighbor);
```

### 4.2 确定性排序

```csharp
// AStarNode 的 CompareTo 方法确保确定性排序
public int CompareTo(AStarNode other)
{
    // 1. 首先比较f值
    int fCompare = f.CompareTo(other.f);
    if (fCompare != 0) return fCompare;
    
    // 2. f值相同时，使用位置作为tie-breaker
    int xCompare = position.x.CompareTo(other.position.x);
    if (xCompare != 0) return xCompare;
    return position.y.CompareTo(other.position.y);
}
```

### 4.3 确定性遍历

```csharp
// 邻居列表必须排序，确保遍历顺序确定
neighbors.Sort((a, b) =>
{
    int xCompare = a.x.CompareTo(b.x);
    if (xCompare != 0) return xCompare;
    return a.y.CompareTo(b.y);
});
```

### 4.4 无随机性

- ❌ 不使用 `Random`
- ❌ 不使用 `UnityEngine.Random`
- ✅ 所有操作都是确定的

## 五、性能优化

### 5.1 使用对象池

```csharp
// 复用List和Dictionary，减少GC
private static List<GridNode> _neighborBuffer = new List<GridNode>();
private static Dictionary<GridNode, GridNode> _cameFromBuffer = new Dictionary<GridNode, GridNode>();
```

### 5.2 JPS优化（可选）

如果地图很大，可以考虑实现JPS（Jump Point Search）：
- 跳过不必要的节点
- 减少开放集大小
- 提高性能

### 5.3 路径平滑（可选）

找到路径后，可以进行路径平滑：
```csharp
// 移除不必要的中间节点
List<FixVector2> SmoothPath(List<FixVector2> path, GridMapComponent map)
{
    // 检查是否可以直线到达，如果可以则移除中间节点
    // ...
}
```

## 六、使用示例

### 6.1 在System中使用

```csharp
public class ZombieAISystem : ISystem
{
    public void Execute(World world, List<FrameData> inputs)
    {
        // 获取地图组件（假设只有一个）
        var mapEntity = world.CreateQuery().WithAll<GridMapComponent>().GetEntities().FirstOrDefault();
        if (!mapEntity.HasValue) return;
        
        var map = world.GetComponent<GridMapComponent>(mapEntity.Value);
        
        // 获取所有僵尸
        foreach (var (entity, transform, ai) in 
            world.GetEntitiesWithComponents<Transform2DComponent, ZombieAIComponent>())
        {
            // 获取目标位置
            FixVector2 target = ai.targetPosition;
            
            // 寻路
            var path = DeterministicPathfinding.FindPath(map, transform.position, target);
            
            if (path != null && path.Count > 1)
            {
                // 移动到路径的下一个点
                FixVector2 nextPoint = path[1];
                // 更新AI状态...
            }
        }
    }
}
```

### 6.2 组件设计

```csharp
// 僵尸AI组件
public struct ZombieAIComponent : IComponent
{
    public FixVector2 targetPosition;
    public List<FixVector2> currentPath;
    public int currentPathIndex;
    public Fix64 moveSpeed;
}

// 寻路请求组件（用于异步寻路）
public struct PathfindingRequestComponent : IComponent
{
    public FixVector2 start;
    public FixVector2 end;
    public Entity requester;  // 请求寻路的Entity
}
```

## 七、注意事项

### 7.1 性能考虑

- **寻路频率**：不要每帧都寻路，可以：
  - 目标改变时寻路
  - 每N帧寻路一次
  - 使用寻路请求队列

### 7.2 内存管理

- 使用对象池复用List和Dictionary
- 及时清理不需要的路径数据

### 7.3 调试

- 可视化路径（在Unity中绘制）
- 记录寻路时间
- 检查路径是否确定

## 八、进阶优化

### 8.1 分层寻路

- 粗粒度寻路：大区域之间的路径
- 细粒度寻路：区域内的详细路径

### 8.2 路径缓存

- 缓存常用路径
- 路径失效检测（障碍物变化时）

### 8.3 动态障碍物

- 实时更新障碍物
- 路径重规划

## 九、总结

1. ✅ **使用A*算法**：高效且可确定性
2. ✅ **固定点数学**：所有计算使用Fix64
3. ✅ **确定性排序**：tie-breaker确保顺序
4. ✅ **网格地图**：简单且确定
5. ✅ **性能优化**：对象池、JPS等

这套方案可以确保所有客户端产生完全相同的路径，满足帧同步的要求。

