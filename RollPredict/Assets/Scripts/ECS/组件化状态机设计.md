# 组件化模式下的状态机设计

## 问题分析

在组件分离模式下，状态机的处理需要考虑：

1. **通用状态**（所有实体都可能有的）
   - 僵直状态（Stiff/HitStun）
   - 死亡状态（Death）
   - 无敌状态（Invincible）

2. **实体特有状态**（特定实体才有的）
   - 玩家：Normal, HitStun（但HitStun可以通用化）
   - 僵尸：Chase, AttackWindup, Attack, AttackCooldown

## 设计方案

### 方案1：完全通用化状态机（不推荐）

**设计：**
```csharp
// 通用状态组件
public struct StateComponent : IComponent
{
    public byte stateType;      // 状态类型（需要映射到具体枚举）
    public int stateTimer;       // 状态计时器
}
```

**问题：**
- ❌ 类型不安全（byte需要手动映射）
- ❌ 不同实体的状态类型不同，难以统一
- ❌ 状态转换逻辑复杂

---

### 方案2：混合模式（推荐）⭐

**设计思路：**
- **通用状态**：使用独立组件（`StiffComponent`, `HPComponent`等）
- **实体特有状态**：保留在实体特有的Component中

**实现：**

#### 1. 通用状态组件（可复用）

```csharp
// 僵直组件（通用）
public struct StiffComponent : IComponent
{
    public int stiffTimer;
    public int stiffDuration;
}

// 血量组件（通用）
public struct HPComponent : IComponent
{
    public int HP;
    public int maxHP;
}
```

#### 2. 实体特有状态（保留在特有Component中）

```csharp
// PlayerComponent - 保留玩家特有的状态
public struct PlayerComponent : IComponent
{
    public int playerId;
    public int currentIndex;  // 切换模式（0=墙, 1=子弹）
    // ... 其他玩家特有数据
    // 注意：不再包含HP和僵直状态
}

// ZombieAIComponent - 保留僵尸特有的AI状态
public struct ZombieAIComponent : IComponent
{
    public ZombieState state;  // Chase, AttackWindup, Attack, AttackCooldown
    // ... 其他AI相关数据
}
```

#### 3. 状态机System设计

```csharp
// StiffSystem - 处理所有实体的僵直状态（通用）
public class StiffSystem : ISystem
{
    public void Execute(World world, List<FrameData> inputs)
    {
        // 处理所有有StiffComponent的实体
        foreach (var (entity, stiff) in world.GetEntitiesWithComponents<StiffComponent>())
        {
            if (stiff.stiffTimer > 0)
            {
                var updatedStiff = stiff;
                updatedStiff.stiffTimer--;
                world.AddComponent(entity, updatedStiff);
            }
        }
    }
}

// ZombieAISystem - 处理僵尸特有的AI状态机
public class ZombieAISystem : ISystem
{
    public void Execute(World world, List<FrameData> inputs)
    {
        foreach (var (entity, ai) in world.GetEntitiesWithComponents<ZombieAIComponent>())
        {
            // 检查是否在僵直状态（如果有StiffComponent）
            if (world.TryGetComponent<StiffComponent>(entity, out var stiff))
            {
                if (stiff.stiffTimer > 0)
                {
                    // 僵直状态下，僵尸无法移动和攻击
                    // 可以在这里设置velocity为0，或者直接continue
                    continue;
                }
            }
            
            // 正常的AI状态机逻辑
            switch (ai.state)
            {
                case ZombieState.Chase:
                    // ...
                    break;
                // ...
            }
        }
    }
}
```

---

### 方案3：状态机组件 + 状态类型（高级方案）

**设计：**
```csharp
// 通用状态机组件
public struct StateMachineComponent<T> : IComponent where T : Enum
{
    public T currentState;
    public int stateTimer;
}

// 使用
public struct PlayerStateMachine : StateMachineComponent<PlayerState> { }
public struct ZombieStateMachine : StateMachineComponent<ZombieState> { }
```

**问题：**
- ❌ C# 不支持泛型结构体约束到 Enum（需要变通）
- ❌ 实现复杂，可能影响性能
- ❌ 对于当前需求来说过于复杂

---

## 推荐方案：混合模式（方案2）

### 设计原则

1. **通用能力组件化**
   - 僵直 → `StiffComponent`
   - 血量 → `HPComponent`
   - 死亡 → `DeathComponent`（未来）

2. **实体特有状态保留**
   - 玩家特有状态 → `PlayerComponent`（如切换模式）
   - 僵尸AI状态 → `ZombieAIComponent`（Chase, Attack等）

3. **状态检查顺序**
   - 先检查通用状态（僵直、死亡等）
   - 再处理实体特有状态

### 实现示例

#### 僵尸在僵直状态下的行为

```csharp
// ZombieAISystem
public void Execute(World world, List<FrameData> inputs)
{
    foreach (var (entity, ai) in world.GetEntitiesWithComponents<ZombieAIComponent>())
    {
        // 1. 检查通用状态：僵直
        if (world.TryGetComponent<StiffComponent>(entity, out var stiff))
        {
            if (stiff.stiffTimer > 0)
            {
                // 僵直状态：停止移动和攻击
                if (world.TryGetComponent<VelocityComponent>(entity, out var velocity))
                {
                    velocity.velocity = FixVector2.Zero;
                    world.AddComponent(entity, velocity);
                }
                continue; // 跳过AI逻辑
            }
        }
        
        // 2. 处理僵尸特有的AI状态
        switch (ai.state)
        {
            case ZombieState.Chase:
                // 正常追逐逻辑
                break;
            // ...
        }
    }
}
```

#### 玩家在僵直状态下的行为

```csharp
// PlayerMoveSystem
public void Execute(World world, List<FrameData> inputs)
{
    foreach (var frameData in inputs)
    {
        Entity? playerEntity = FindPlayerEntity(world, frameData.PlayerId);
        if (!playerEntity.HasValue) continue;
        
        // 检查僵直状态
        if (world.TryGetComponent<StiffComponent>(playerEntity.Value, out var stiff))
        {
            if (stiff.stiffTimer > 0)
            {
                continue; // 僵直状态下无法移动
            }
        }
        
        // 正常移动逻辑
        // ...
    }
}
```

---

## 状态机层次结构

```
Entity
├── 通用状态组件（可复用）
│   ├── HPComponent（血量）
│   ├── StiffComponent（僵直）
│   └── DeathComponent（死亡，未来）
│
└── 实体特有组件
    ├── PlayerComponent（玩家特有：playerId, currentIndex等）
    └── ZombieAIComponent（僵尸特有：AI状态机）
```

### 状态检查优先级

1. **通用状态优先**（僵直、死亡等）
   - 这些状态会阻止其他行为
   - 在System中先检查

2. **实体特有状态其次**（AI状态、玩家模式等）
   - 在通用状态检查通过后执行

---

## 总结

**推荐使用混合模式（方案2）：**

✅ **优点：**
- 通用能力（僵直、血量）可复用
- 实体特有状态保留在特有Component中
- 实现简单，易于理解
- 类型安全，性能好

✅ **实现要点：**
- `StiffComponent`：通用僵直状态
- `HPComponent`：通用血量
- `StiffSystem`：统一处理所有实体的僵直
- 各System先检查通用状态，再处理特有逻辑

✅ **扩展性：**
- 未来添加Boss、NPC等，只需添加相应组件
- 通用能力自动生效
- 不需要修改现有代码

