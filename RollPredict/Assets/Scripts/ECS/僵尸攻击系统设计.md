# 僵尸攻击系统设计文档

## 概述
实现僵尸攻击玩家的完整流程，包括攻击范围检测、攻击状态机、伤害判定等。

## 系统架构

### 1. 组件设计

#### 1.1 ZombieAIComponent（扩展）
```csharp
public enum ZombieState
{
    Idle,           // 空闲（未找到目标）
    Chase,           // 追逐（寻路移动）
    AttackWindup,    // 攻击前摇
    Attack,          // 攻击中（伤害判定帧）
    AttackCooldown   // 攻击后摇
}

public struct ZombieAIComponent
{
    // 现有字段...
    
    // 新增字段
    public ZombieState state;              // 当前状态
    public FixVector2 attackDirection;     // 攻击方向（进入攻击状态时保存）
    public int attackWindupTimer;           // 前摇计时器（帧数）
    public int attackCooldownTimer;         // 后摇计时器（帧数）
    public Entity targetPlayerEntity;       // 目标玩家Entity（攻击时锁定）
}
```

#### 1.2 ZombieAttackComponent（新增）
```csharp
/// <summary>
/// 僵尸攻击组件：存储攻击相关配置和状态
/// </summary>
public struct ZombieAttackComponent : IComponent
{
    // 攻击范围（外层触发器半径）
    public Fix64 attackRange;
    
    // 攻击伤害
    public int damage;
    
    // 攻击前摇时间（帧数）
    public int windupFrames;
    
    // 攻击后摇时间（帧数）
    public int cooldownFrames;
    
    // 攻击伤害判定范围（前方扇形/矩形）
    public Fix64 attackDamageRange;      // 伤害判定距离
    public Fix64 attackDamageAngle;     // 伤害判定角度（扇形）
    // 或使用矩形：attackDamageWidth, attackDamageHeight
}
```

### 2. 系统设计

#### 2.1 ZombieAttackSystem（新增）
负责处理僵尸攻击的完整流程：

**执行顺序**：
1. **状态检测**：检查僵尸当前状态
2. **范围检测**：检测玩家是否进入攻击范围
3. **状态转换**：根据条件转换状态
4. **状态处理**：
   - `Chase`：正常寻路移动
   - `AttackWindup`：前摇计时，停止移动
   - `Attack`：伤害判定帧，检测前方区域玩家
   - `AttackCooldown`：后摇计时，停止移动
5. **状态重置**：后摇结束后回到 `Chase` 状态

#### 2.2 ZombieAISystem（修改）
- 只在 `Chase` 状态时执行寻路和移动
- 其他状态时停止移动

### 3. 攻击流程详解

#### 3.1 攻击范围检测（外层触发器）
```
僵尸位置
    |
    |  [攻击范围] ← 外层触发器（大圆）
    |     |
    |  [僵尸本体] ← 碰撞体（小圆）
    |
```

**实现方式**：
- 使用 `CollisionShapeComponent` 创建更大的圆形触发器
- 设置 `PhysicsBodyComponent.isTrigger = true`
- 通过 `CollisionComponent` 检测玩家是否在范围内

#### 3.2 攻击状态转换
```
Chase (追逐)
  ↓ [玩家进入攻击范围]
AttackWindup (前摇)
  ↓ [前摇计时器 = 0]
Attack (攻击判定)
  ↓ [伤害判定完成]
AttackCooldown (后摇)
  ↓ [后摇计时器 = 0]
Chase (继续追逐)
```

#### 3.3 伤害判定
在 `Attack` 状态的特定帧（前摇结束的瞬间）：
1. 获取进入攻击状态时保存的 `attackDirection`
2. 检测前方扇形/矩形区域内的玩家
3. 对范围内的玩家造成伤害
4. 立即进入 `AttackCooldown` 状态

**伤害判定区域**：
- **方案1（扇形）**：以僵尸位置为圆心，`attackDirection` 为方向，`attackDamageRange` 为半径，`attackDamageAngle` 为角度
- **方案2（矩形）**：以僵尸位置为起点，`attackDirection` 为方向，`attackDamageWidth` × `attackDamageHeight` 的矩形

### 4. 实现细节

#### 4.1 攻击范围检测
```csharp
// 在 ZombieAttackSystem 中
private bool IsPlayerInAttackRange(World world, Entity zombieEntity, 
    Transform2DComponent zombieTransform, ZombieAttackComponent attack)
{
    // 遍历所有玩家
    foreach (var (playerEntity, playerTransform, _) in 
        world.GetEntitiesWithComponents<Transform2DComponent, PlayerComponent>())
    {
        FixVector2 diff = playerTransform.position - zombieTransform.position;
        Fix64 distance = Fix64.Sqrt(diff.x * diff.x + diff.y * diff.y);
        
        if (distance <= attack.attackRange)
        {
            return true; // 玩家在攻击范围内
        }
    }
    return false;
}
```

#### 4.2 伤害判定
```csharp
// 在 Attack 状态时执行
private void CheckAttackDamage(World world, Entity zombieEntity,
    Transform2DComponent zombieTransform, ZombieAIComponent ai,
    ZombieAttackComponent attack)
{
    // 获取攻击方向
    FixVector2 attackDir = ai.attackDirection;
    
    // 检测前方区域内的玩家
    foreach (var (playerEntity, playerTransform, playerComponent) in
        world.GetEntitiesWithComponents<Transform2DComponent, PlayerComponent>())
    {
        FixVector2 toPlayer = playerTransform.position - zombieTransform.position;
        Fix64 distance = Fix64.Sqrt(toPlayer.x * toPlayer.x + toPlayer.y * toPlayer.y);
        
        // 检查距离
        if (distance > attack.attackDamageRange)
            continue;
        
        // 检查角度（扇形判定）
        toPlayer.Normalize();
        Fix64 dot = FixVector2.Dot(attackDir, toPlayer);
        Fix64 angle = Fix64.Acos(dot); // 角度（弧度）
        
        if (angle <= attack.attackDamageAngle / Fix64.Two)
        {
            // 玩家在攻击范围内，造成伤害
            ApplyDamage(world, playerEntity, attack.damage);
        }
    }
}
```

#### 4.3 状态机实现
```csharp
public void Execute(World world, List<FrameData> inputs)
{
    foreach (var (zombieEntity, transform, ai, attack) in
        world.GetEntitiesWithComponents<Transform2DComponent, ZombieAIComponent, ZombieAttackComponent>())
    {
        var updatedAI = ai;
        
        switch (ai.state)
        {
            case ZombieState.Chase:
                // 检查是否进入攻击范围
                if (IsPlayerInAttackRange(world, zombieEntity, transform, attack))
                {
                    // 找到最近的玩家，保存攻击方向
                    var nearestPlayer = FindNearestPlayer(world, transform.position);
                    if (nearestPlayer.HasValue)
                    {
                        FixVector2 toPlayer = nearestPlayer.Value.position - transform.position;
                        toPlayer.Normalize();
                        
                        updatedAI.state = ZombieState.AttackWindup;
                        updatedAI.attackDirection = toPlayer;
                        updatedAI.targetPlayerEntity = nearestPlayer.Value.entity;
                        updatedAI.attackWindupTimer = attack.windupFrames;
                    }
                }
                break;
                
            case ZombieState.AttackWindup:
                // 前摇计时
                updatedAI.attackWindupTimer--;
                if (updatedAI.attackWindupTimer <= 0)
                {
                    updatedAI.state = ZombieState.Attack;
                }
                break;
                
            case ZombieState.Attack:
                // 伤害判定
                CheckAttackDamage(world, zombieEntity, transform, updatedAI, attack);
                
                // 立即进入后摇
                updatedAI.state = ZombieState.AttackCooldown;
                updatedAI.attackCooldownTimer = attack.cooldownFrames;
                break;
                
            case ZombieState.AttackCooldown:
                // 后摇计时
                updatedAI.attackCooldownTimer--;
                if (updatedAI.attackCooldownTimer <= 0)
                {
                    // 回到追逐状态
                    updatedAI.state = ZombieState.Chase;
                }
                break;
        }
        
        world.AddComponent(zombieEntity, updatedAI);
    }
}
```

### 5. 伤害系统

#### 5.1 伤害应用
```csharp
private void ApplyDamage(World world, Entity playerEntity, int damage)
{
    if (world.TryGetComponent<PlayerComponent>(playerEntity, out var player))
    {
        var updatedPlayer = player;
        updatedPlayer.HP = Fix64.Max(0, updatedPlayer.HP - damage);
        world.AddComponent(playerEntity, updatedPlayer);
        
        // 如果血量 <= 0，触发死亡（后续实现）
        if (updatedPlayer.HP <= 0)
        {
            // HandlePlayerDeath(world, playerEntity);
        }
    }
}
```

### 6. 系统执行顺序

在 `ECSStateMachine` 中的执行顺序：
1. `ZombieAISystem`：处理寻路和移动（只在 `Chase` 状态）
2. `ZombieAttackSystem`：处理攻击状态机和伤害判定
3. `PhysicsSystem`：处理物理碰撞（包括攻击范围检测）

### 7. 配置参数

#### 7.1 默认配置
```csharp
// ZombieSpawnSystem 中创建僵尸时设置
var attackComponent = new ZombieAttackComponent
{
    attackRange = (Fix64)2.0f,           // 攻击范围：2单位
    damage = 10,                         // 伤害：10点
    windupFrames = 10,                   // 前摇：10帧
    cooldownFrames = 20,                 // 后摇：20帧
    attackDamageRange = (Fix64)1.5f,     // 伤害判定距离：1.5单位
    attackDamageAngle = (Fix64)(60 * Math.PI / 180) // 伤害判定角度：60度
};
```

### 8. 优化考虑

1. **性能优化**：
   - 攻击范围检测可以复用 `PhysicsSystem` 的碰撞检测结果
   - 使用 `CollisionComponent` 记录玩家是否在攻击范围内

2. **确定性**：
   - 所有计算使用 `Fix64` 固定点数学
   - 状态转换条件明确，避免浮点数误差

3. **扩展性**：
   - 支持不同类型的攻击（近战、远程等）
   - 支持攻击动画（通过状态机控制）

## 实现步骤

1. ✅ 创建 `ZombieAttackComponent`
2. ✅ 扩展 `ZombieAIComponent`（添加状态字段）
3. ✅ 创建 `ZombieAttackSystem`
4. ✅ 修改 `ZombieAISystem`（只在 `Chase` 状态移动）
5. ✅ 实现伤害系统
6. ✅ 在 `ZombieSpawnSystem` 中添加攻击组件
7. ✅ 注册系统到 `ECSStateMachine`

