# 僵尸攻击区域检测方案

## 需求
1. 使用 QuadTree 进行区域检测（不创建触发器）
2. 在 Chase 状态下，每两帧检测一次圆形区域
3. 通过 layer 筛选玩家

## 方案设计

### 1. PhysicsSystem 扩展
添加公共方法，允许其他系统查询 QuadTree：

```csharp
/// <summary>
/// 查询指定圆形区域内的Entity（通过QuadTree）
/// </summary>
/// <param name="center">圆心位置</param>
/// <param name="radius">半径</param>
/// <param name="layerMask">层掩码（只返回匹配的层，-1表示所有层）</param>
/// <returns>匹配的Entity列表</returns>
public List<Entity> QueryCircleRegion(World world, FixVector2 center, Fix64 radius, int layerMask = -1)
{
    // 将圆形转换为AABB（用于QuadTree查询）
    FixRect aabb = new FixRect(
        center.x - radius,  // x
        center.y - radius,  // y
        radius * Fix64.Two, // width
        radius * Fix64.Two  // height
    );
    
    // 查询AABB区域内的所有Entity
    var candidates = quadTree.Query(aabb);
    
    // 筛选：精确圆形检测 + layer过滤
    var result = new List<Entity>();
    foreach (var entity in candidates)
    {
        // 1. 检查layer（如果指定了layerMask）
        if (layerMask >= 0)
        {
            if (!world.TryGetComponent<PhysicsBodyComponent>(entity, out var body))
                continue;
            if (body.layer != layerMask)
                continue;
        }
        
        // 2. 精确圆形检测
        if (!world.TryGetComponent<Transform2DComponent>(entity, out var transform))
            continue;
        
        FixVector2 diff = transform.position - center;
        Fix64 distanceSqr = diff.x * diff.x + diff.y * diff.y;
        Fix64 radiusSqr = radius * radius;
        
        if (distanceSqr <= radiusSqr)
        {
            result.Add(entity);
        }
    }
    
    return result;
}
```

### 2. ZombieAIComponent 扩展
添加攻击检测相关字段：

```csharp
/// <summary>
/// 攻击检测冷却（每N帧检测一次）
/// </summary>
public int attackDetectionCooldown;

/// <summary>
/// 攻击范围（圆形半径）
/// </summary>
public Fix64 attackRange;

/// <summary>
/// 玩家层（用于筛选）
/// </summary>
public int playerLayer;
```

### 3. ZombieAISystem 修改
在 Chase 状态下，每两帧检测一次：

```csharp
case ZombieState.Chase:
    // 更新攻击检测冷却
    if (updatedAI.attackDetectionCooldown > 0)
    {
        updatedAI.attackDetectionCooldown--;
    }
    else
    {
        // 每两帧检测一次攻击范围
        updatedAI.attackDetectionCooldown = 2;
        
        // 使用PhysicsSystem查询圆形区域
        var physicsSystem = ECSStateMachine.GetSystem<PhysicsSystem>();
        if (physicsSystem != null)
        {
            var playersInRange = physicsSystem.QueryCircleRegion(
                world,
                transform.position,
                updatedAI.attackRange,
                updatedAI.playerLayer  // 只查询玩家层
            );
            
            if (playersInRange.Count > 0)
            {
                // 找到最近的玩家，进入攻击状态
                Entity? nearestPlayer = FindNearestPlayer(playersInRange, transform.position);
                if (nearestPlayer.HasValue)
                {
                    // 计算攻击方向
                    if (world.TryGetComponent<Transform2DComponent>(nearestPlayer.Value, out var playerTransform))
                    {
                        FixVector2 toPlayer = playerTransform.position - transform.position;
                        toPlayer.Normalize();
                        
                        updatedAI.state = ZombieState.AttackWindup;
                        updatedAI.attackDirection = toPlayer;
                        updatedAI.attackWindupTimer = 10; // 前摇10帧
                    }
                }
            }
        }
    }
    break;
```

## 实现步骤

1. ✅ 在 PhysicsSystem 中添加 QueryCircleRegion 方法
2. ✅ 扩展 ZombieAIComponent（添加攻击检测字段）
3. ✅ 修改 ZombieAISystem（使用 QuadTree 查询）
4. ✅ 在 ZombieSpawnSystem 中设置攻击范围和玩家层

## 优势

1. **性能优化**：使用 QuadTree 宽相位检测，只对候选Entity进行精确检测
2. **无需触发器**：不需要创建额外的碰撞体
3. **Layer筛选**：支持通过layer精确筛选目标
4. **确定性**：所有计算使用Fix64，确保帧同步

## Layer 定义建议

```csharp
// 物理层定义
public static class PhysicsLayers
{
    public const int Default = 0;
    public const int Player = 1;
    public const int Zombie = 2;
    public const int Bullet = 3;
    public const int Wall = 4;
}
```


