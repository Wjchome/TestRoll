# 血量显示方案设计

## 架构原则
- **数据层**：ECS World（包含 PlayerComponent.hp）
- **视图层**：ECSSyncHelper（唯一的视图层代码）
- **UI层**：Unity GameObject（Text、Image、Slider等）

## 方案对比

### 方案1：通过 GameObject 组件（推荐）
**优点**：
- 符合 Unity 组件化设计
- 灵活：每个玩家可以有独立的 UI 样式
- 易于扩展：可以添加其他 UI 元素（血条、名字等）

**实现**：
1. 在玩家 GameObject 上挂载 `PlayerUIComponent` 脚本
2. `ECSSyncHelper` 同步血量到该组件
3. 组件负责更新 UI 显示

### 方案2：直接维护 UI 映射
**优点**：
- 简单直接
- 不需要额外的组件

**缺点**：
- 所有玩家共享相同的 UI 样式
- 扩展性较差

## 推荐实现：方案1

### 1. 创建 PlayerUIComponent 脚本
```csharp
// 挂载在玩家 GameObject 上
public class PlayerUIComponent : MonoBehaviour
{
    [Header("血量显示")]
    public Text healthText;        // 可选：血量文本
    public Slider healthBar;       // 可选：血量条
    public Image healthBarFill;    // 可选：血量条填充
    
    private int maxHp = 100;
    
    public void UpdateHealth(int currentHp, int maxHp)
    {
        this.maxHp = maxHp;
        
        // 更新文本
        if (healthText != null)
        {
            healthText.text = $"{currentHp}/{maxHp}";
        }
        
        // 更新血条
        if (healthBar != null)
        {
            healthBar.value = (float)currentHp / maxHp;
        }
        
        // 更新填充图片
        if (healthBarFill != null)
        {
            healthBarFill.fillAmount = (float)currentHp / maxHp;
        }
    }
}
```

### 2. 在 ECSSyncHelper 中同步血量
```csharp
public static void SyncFromWorldToUnity(World world)
{
    // ... 现有的同步代码 ...
    
    // 同步玩家血量UI
    SyncPlayerHealthUI(world);
}

private static void SyncPlayerHealthUI(World world)
{
    foreach (var (entity, playerComponent) in world.GetEntitiesWithComponents<PlayerComponent>())
    {
        if (_entityToGameObject.TryGetValue(entity.Id, out var playerGO))
        {
            var uiComponent = playerGO.GetComponent<PlayerUIComponent>();
            if (uiComponent != null)
            {
                // 假设最大血量为100（可以从PlayerComponent或配置中获取）
                int maxHp = 100; // TODO: 从配置或组件中获取
                uiComponent.UpdateHealth(playerComponent.hp, maxHp);
            }
        }
    }
}
```

### 3. 在 RegisterPlayer 时初始化
```csharp
public static Entity RegisterPlayer(World world, int playerId, GameObject gameObject,
    FixVector2 initialPosition, int initialHp)
{
    // ... 现有代码 ...
    
    // 初始化 UI 组件（如果存在）
    var uiComponent = gameObject.GetComponent<PlayerUIComponent>();
    if (uiComponent != null)
    {
        uiComponent.UpdateHealth(initialHp, initialHp); // 初始化时最大血量 = 当前血量
    }
    
    return entity;
}
```

## 扩展性
- 可以轻松添加其他 UI 元素（分数、名字、状态图标等）
- 每个玩家可以有独立的 UI 样式
- 支持多种显示方式（文本、血条、图片等）

## 性能考虑
- 只在血量变化时更新（可以添加缓存优化）
- UI 更新频率可以降低（不需要每帧更新）

