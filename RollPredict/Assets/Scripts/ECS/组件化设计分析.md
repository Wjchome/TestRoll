# 僵尸僵直状态实现方案分析

## 方案对比

### 方案1：直接在 ZombieAISystem 中处理

**实现方式：**
- 在 `ZombieAIComponent` 中添加 `hitStunTimer` 字段
- 在 `ZombieAISystem` 中处理僵直逻辑
- 在僵直状态下，僵尸无法移动、攻击

**优点：**
- ✅ 实现简单，代码集中
- ✅ 不需要创建新组件
- ✅ 僵尸相关逻辑都在一个地方

**缺点：**
- ❌ 代码重复（玩家和僵尸都有僵直逻辑）
- ❌ 不符合ECS设计原则（状态应该放在Component中）
- ❌ 如果未来有其他实体需要僵直，需要再次重复代码
- ❌ 僵尸Component职责过重（包含AI、攻击、僵直等）

---

### 方案2：组件化设计（推荐）

**实现方式：**
- 创建 `HPComponent`：存储血量相关数据（HP, maxHP）
- 创建 `StiffComponent`：存储僵直状态（timer, duration）
- 创建 `ZombieDamageHelper`：统一处理僵尸伤害
- 创建 `StiffSystem`：统一处理所有实体的僵直状态

**组件设计：**

```csharp
// HPComponent - 通用血量组件
public struct HPComponent : IComponent
{
    public int HP;
    public int maxHP;
}

// StiffComponent - 通用僵直组件
public struct StiffComponent : IComponent
{
    public int stiffTimer;        // 当前僵直计时器
    public int stiffDuration;      // 僵直持续时间（配置）
}
```

**优点：**
- ✅ **符合ECS设计原则**：数据在Component，逻辑在System
- ✅ **高度可复用**：任何实体都可以添加这些组件来获得相应能力
- ✅ **职责清晰**：每个组件只负责一个方面
- ✅ **易于扩展**：未来添加新实体（Boss、NPC等）只需添加组件
- ✅ **统一管理**：所有僵直逻辑在一个System中处理
- ✅ **代码复用**：玩家和僵尸共享相同的僵直逻辑

**缺点：**
- ❌ 需要创建新组件和System
- ❌ 需要重构现有代码（将HP从PlayerComponent中分离）

---

## 推荐方案：组件化设计（方案2）

### 理由

1. **符合ECS架构原则**
   - ECS的核心思想是"组合优于继承"
   - 通过组合不同的Component来构建实体
   - 每个Component只负责一个方面的数据

2. **未来扩展性**
   - 如果未来需要添加Boss、NPC等实体，只需添加相应组件
   - 不需要修改现有代码

3. **代码复用**
   - 僵直逻辑只需要实现一次
   - 所有实体共享相同的System

4. **职责分离**
   - `PlayerComponent`：只负责玩家特有的数据（playerId, currentIndex等）
   - `HPComponent`：负责血量（玩家、僵尸、Boss都可以用）
   - `StiffComponent`：负责僵直状态（任何实体都可以用）
   - `ZombieAIComponent`：只负责AI相关数据

### 实现步骤

1. **创建通用组件**
   - `HPComponent`：血量组件
   - `StiffComponent`：僵直组件

2. **创建统一System**
   - `StiffSystem`：处理所有实体的僵直状态
   - `ZombieDamageHelper`：处理僵尸伤害（类似PlayerDamageHelper）

3. **重构现有代码**
   - 将 `PlayerComponent` 中的HP分离到 `HPComponent`
   - 将 `PlayerComponent` 中的僵直状态分离到 `StiffComponent`
   - 更新 `PlayerDamageHelper` 使用新组件

4. **僵尸实现**
   - 僵尸添加 `HPComponent` 和 `StiffComponent`
   - 使用 `ZombieDamageHelper` 处理伤害
   - `StiffSystem` 自动处理僵直状态

---

## 组件设计示例

### HPComponent
```csharp
public struct HPComponent : IComponent
{
    public int HP;
    public int maxHP;
    
    public HPComponent(int maxHP)
    {
        this.maxHP = maxHP;
        this.HP = maxHP;
    }
}
```

### StiffComponent
```csharp
public struct StiffComponent : IComponent
{
    public int stiffTimer;
    public int stiffDuration;  // 配置值，可以不同实体不同
    
    public static int DefaultDuration = 10;  // 默认10帧
    
    public StiffComponent(int duration = 0)
    {
        this.stiffDuration = duration > 0 ? duration : DefaultDuration;
        this.stiffTimer = 0;
    }
}
```

### StiffSystem
```csharp
public class StiffSystem : ISystem
{
    public void Execute(World world, List<FrameData> inputs)
    {
        // 处理所有有StiffComponent的实体
        foreach (var (entity, stiff) in world.GetEntitiesWithComponents<StiffComponent>())
        {
            if (stiff.stiffTimer > 0)
            {
                var updatedStiff = stiff;
                updatedStiff.stiffTimer--;
                world.AddComponent(entity, updatedStiff);
            }
        }
    }
}
```

---

## 总结

**推荐使用方案2（组件化设计）**，因为：
1. 更符合ECS架构原则
2. 代码可复用性高
3. 易于扩展和维护
4. 职责清晰，便于理解

虽然需要一些重构工作，但长期来看收益更大。

