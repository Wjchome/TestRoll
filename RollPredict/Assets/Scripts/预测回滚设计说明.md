# 帧同步预测回滚设计说明

## 核心设计原则

### 1. 哪些需要预测回滚？

**需要预测回滚的状态：**
- ✅ **玩家状态**：位置、生命值、分数等影响游戏逻辑的数据
- ✅ **物理体状态**：位置、速度（质量、形状等静态属性不需要）
- ✅ **游戏逻辑状态**：技能CD、Buff状态、道具状态等
- ❌ **不需要预测回滚的**：UI状态、特效、音效等纯表现层内容

**判断标准：**
- 如果这个状态会影响游戏逻辑的确定性结果 → 需要预测回滚
- 如果这个状态只是视觉效果 → 不需要预测回滚

### 2. 引用关系怎么处理？

**核心原则：GameState只存储数据，不存储Unity对象引用**

#### 为什么不能存储引用？
- Unity对象在回滚时可能被销毁/重建
- 引用在序列化/反序列化时会丢失
- 不同客户端可能有不同的对象实例

#### 解决方案：使用ID映射

```csharp
// ❌ 错误：直接存储引用
public Dictionary<int, RigidBody2D> physicsBodies; // 不能这样做！

// ✅ 正确：存储数据，使用ID映射
public Dictionary<int, PhysicsBodyState> physicsBodies; // 只存储数据
private static Dictionary<int, RigidBody2D> bodyIdToRigidBody; // ID到对象的映射
```

#### 工作流程：

1. **注册阶段**：物理体创建时，注册ID映射
   ```csharp
   StateSyncHelper.RegisterPhysicsBody(rigidBody);
   ```

2. **保存状态**：从Unity对象保存到GameState
   ```csharp
   StateSyncHelper.SavePhysicsStateToGameState(gameState, physicsWorld);
   ```

3. **恢复状态**：从GameState恢复到Unity对象
   ```csharp
   StateSyncHelper.RestorePhysicsStateFromGameState(gameState, physicsWorld);
   ```

### 3. GameState用结构体还是类？

**使用类（class），原因如下：**

1. **需要深拷贝**：回滚时需要完整复制状态
   ```csharp
   GameState snapshot = currentState.Clone(); // 需要深拷贝
   ```

2. **包含引用类型**：Dictionary、List等引用类型
   ```csharp
   public Dictionary<int, PlayerState> players; // 引用类型
   ```

3. **结构体的限制**：
   - 结构体包含引用类型时，浅拷贝会导致引用共享
   - 结构体过大时性能反而下降
   - 结构体不能很好地支持继承和扩展

4. **类的优势**：
   - 明确的引用语义
   - 易于实现深拷贝
   - 支持序列化（[Serializable]）
   - 内存管理更灵活

## 架构设计

### 数据层（GameState）

```csharp
public class GameState
{
    // 玩家状态（使用ID作为Key）
    public Dictionary<int, PlayerState> players;
    
    // 物理体状态（使用ID作为Key）
    public Dictionary<int, PhysicsBodyState> physicsBodies;
    
    // 其他游戏状态...
    
    public GameState Clone() { ... } // 深拷贝
}
```

### 同步层（StateSyncHelper）

负责在GameState（纯数据）和Unity对象之间同步：

```csharp
// 保存：Unity对象 → GameState
StateSyncHelper.SavePhysicsStateToGameState(gameState, physicsWorld);

// 恢复：GameState → Unity对象
StateSyncHelper.RestorePhysicsStateFromGameState(gameState, physicsWorld);
```

### 逻辑层（StateMachine）

执行游戏逻辑，不直接操作Unity对象：

```csharp
// State(n+1) = StateMachine(State(n), Input(n))
GameState nextState = StateMachine.Execute(currentState, inputs, physicsWorld);
```

### 管理层（PredictionRollbackManager）

管理预测和回滚流程：

```csharp
// 预测：立即执行输入
PredictInput(playerId, direction);

// 回滚：恢复到确认帧，重新执行
ProcessServerFrame(serverFrame);
```

## 使用示例

### 1. 初始化物理体

```csharp
// 创建物理体时注册
RigidBody2D body = new RigidBody2D(position, mass, shape);
StateSyncHelper.RegisterPhysicsBody(body);
```

### 2. 预测输入

```csharp
// 用户按下按键
PredictionRollbackManager.Instance.PredictInput(playerId, direction);
// 内部流程：
// 1. 保存当前状态快照
// 2. StateMachine.Execute() 执行逻辑
// 3. 物理模拟更新
// 4. 保存新状态快照
```

### 3. 回滚处理

```csharp
// 服务器帧到达，发现预测错误
PredictionRollbackManager.Instance.ProcessServerFrame(serverFrame);
// 内部流程：
// 1. 加载确认帧的快照
// 2. 恢复所有状态到Unity对象
// 3. 重新执行从确认帧到当前帧的所有输入
// 4. 更新确认帧号
```

## 注意事项

### 1. 物理体注册

确保所有需要预测回滚的物理体都已注册：

```csharp
// 在RigidBody2DComponent.Init()中
StateSyncHelper.RegisterPhysicsBody(Body);
```

### 2. 状态一致性

确保GameState和Unity对象状态一致：

- 保存快照前：先执行逻辑，再保存状态
- 回滚时：先恢复状态，再执行逻辑

### 3. 性能优化

- 只保存需要回滚的状态（位置、速度）
- 静态属性（质量、形状）不需要保存
- 使用对象池减少GC

### 4. 确定性

- 所有计算使用定点数（Fix64）
- 避免浮点数误差
- 确保所有客户端计算结果一致

## 扩展指南

### 添加新的状态类型

1. **创建状态数据类**（只包含数据，不包含引用）
   ```csharp
   public class NewState
   {
       public int id;
       public Fix64 value;
       public NewState Clone() { ... }
   }
   ```

2. **添加到GameState**
   ```csharp
   public Dictionary<int, NewState> newStates;
   ```

3. **实现同步逻辑**（如果需要Unity对象）
   ```csharp
   StateSyncHelper.SaveNewStateToGameState(gameState);
   StateSyncHelper.RestoreNewStateFromGameState(gameState);
   ```

4. **在StateMachine中处理**
   ```csharp
   // 在Execute()中添加逻辑
   UpdateNewState(nextState);
   ```

## 总结

- ✅ **GameState使用类**：支持深拷贝和复杂数据结构
- ✅ **使用ID映射**：避免存储Unity对象引用
- ✅ **分离关注点**：数据层、同步层、逻辑层、管理层
- ✅ **只保存必要数据**：位置、速度等影响逻辑的状态
- ✅ **确保确定性**：使用定点数，避免浮点误差

