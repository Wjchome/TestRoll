# 预测回滚系统使用示例

## 快速开始

### 1. 初始化物理体

物理体创建时会自动注册到状态同步系统：

```csharp
// 在RigidBody2DComponent.Init()中已经自动注册
// 无需手动调用，系统会自动处理
```

### 2. 预测输入

当玩家按下按键时：

```csharp
// 用户输入
PredictionRollbackManager.Instance.PredictInput(playerId, InputDirection.DirectionRight);
```

系统会自动：
1. 保存当前状态快照
2. 执行游戏逻辑（包括物理模拟）
3. 保存新状态快照

### 3. 处理服务器帧

当收到服务器帧时：

```csharp
// 服务器帧到达
PredictionRollbackManager.Instance.ProcessServerFrame(serverFrame);
```

系统会自动：
1. 检查是否需要回滚
2. 如果需要回滚，恢复到确认帧
3. 重新执行所有输入

## 完整示例

### 场景设置

1. **添加物理世界组件**
   - 在场景中添加 `PhysicsWorld2DComponent`
   - 配置重力、迭代次数等参数

2. **添加物理体组件**
   - 在需要物理模拟的GameObject上添加 `RigidBody2DComponent`
   - 配置质量、形状等参数

3. **初始化物理体**
   ```csharp
   // 在Start()或适当的地方
   PhysicsWorld2DComponent.Instance.AddRigidBody(
       rigidBodyComponent, 
       initialPosition, 
       PhysicsLayer.Everything
   );
   ```

### 代码示例

```csharp
using UnityEngine;
using Frame.Physics2D;
using Proto;

public class GameController : MonoBehaviour
{
    void Update()
    {
        // 处理玩家输入
        if (Input.GetKeyDown(KeyCode.W))
        {
            PredictionRollbackManager.Instance.PredictInput(
                1, // playerId
                InputDirection.DirectionUp
            );
        }
        
        // 物理世界会在StateMachine.Execute中自动更新
        // 无需手动调用PhysicsWorld2DComponent.Instance.UpdateFrame()
    }
    
    // 处理服务器消息
    void OnServerFrameReceived(ServerFrame serverFrame)
    {
        PredictionRollbackManager.Instance.ProcessServerFrame(serverFrame);
    }
}
```

## 注意事项

### 1. 物理体注册时机

确保物理体在需要预测回滚之前就已经注册：

```csharp
// ✅ 正确：在Init()中注册
public void Init(FixVector2 pos, PhysicsLayer layer)
{
    // ... 创建Body ...
    PhysicsWorld2DComponent.Instance.World.AddBody(Body);
    StateSyncHelper.RegisterPhysicsBody(Body); // 自动注册
}

// ❌ 错误：延迟注册可能导致状态不同步
```

### 2. 不要在Update中手动更新物理

```csharp
// ❌ 错误：不要手动调用
void Update()
{
    PhysicsWorld2DComponent.Instance.UpdateFrame(); // 不要这样做！
}

// ✅ 正确：物理更新在StateMachine.Execute中自动处理
```

### 3. 确保确定性

所有影响游戏逻辑的计算都必须使用定点数：

```csharp
// ✅ 正确：使用定点数
FixVector2 position = new FixVector2((Fix64)1.5m, (Fix64)2.3m);

// ❌ 错误：使用浮点数会导致不同客户端结果不一致
Vector2 position = new Vector2(1.5f, 2.3f);
```

## 调试技巧

### 1. 查看当前状态

```csharp
// 查看当前确认帧
long confirmedFrame = PredictionRollbackManager.Instance.GetConfirmedFrame();

// 查看当前预测帧
long predictedFrame = PredictionRollbackManager.Instance.GetPredictedFrame();

// 查看当前游戏状态
GameState currentState = PredictionRollbackManager.Instance.currentGameState;
```

### 2. 监听回滚事件

```csharp
void Start()
{
    PredictionRollbackManager.Instance.OnRollback += OnRollbackOccurred;
    PredictionRollbackManager.Instance.OnPrediction += OnPredictionOccurred;
}

void OnRollbackOccurred(long frameNumber)
{
    Debug.Log($"回滚到帧 {frameNumber}");
}

void OnPredictionOccurred(long frameNumber)
{
    Debug.Log($"预测到帧 {frameNumber}");
}
```

### 3. 检查物理体状态

```csharp
// 检查GameState中的物理体状态
foreach (var kvp in gameState.physicsBodies)
{
    int bodyId = kvp.Key;
    PhysicsBodyState state = kvp.Value;
    Debug.Log($"物理体 {bodyId}: 位置={state.position}, 速度={state.velocity}");
}
```

## 常见问题

### Q: 物理体状态没有保存？

A: 确保：
1. 物理体已注册（在Init()中自动注册）
2. StateMachine.Execute()传入了physicsWorld参数
3. 物理体在物理世界中（通过AddBody添加）

### Q: 回滚后物理体位置不对？

A: 检查：
1. StateSyncHelper.RestorePhysicsStateFromGameState()是否被调用
2. 物理体的ID是否正确
3. 回滚时是否重新执行了物理模拟

### Q: 性能问题？

A: 优化建议：
1. 减少保存的快照数量（maxSnapshots）
2. 只保存需要回滚的物理体（静态物体不需要）
3. 使用对象池减少GC


